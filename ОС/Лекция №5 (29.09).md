LWP - lightweight processes
LWP - library joz www in Poel ????????????? (стёрла)

pthread library использует функцию ядра clone() -- ту же функцию, которая создаёт процесс. ![[Pasted image 20230929154712.png]]

Summary: в ядре структура потока заранее инициализирована и это как раз LWP. Соответственно когда вызывается функция pthread create, то используется эта заранее инициализированная структура. Потоки поддерживаются системой, ядром. При необходимости кол-во этих инициализированных потоков динамический изменяется.

Это всё, что она хотела рассказать о потоках.

# Взаимодействие параллельных процессов
## Уровни наблюдения
1) Если процесс выполняется от начала до конца, и только после его завершения может выполняться другой процесс - это последовательное выполнение. Процессы не взаимодействуют друг с другом.
2) Квазипараллельное выполнение. Процессы одновременно находятся в памяти и могут обмениваться данными.
3) Многопроцессорная система. Коды процессов выполняются одновременно на разных процессорах.

![[Pasted image 20230929161531.png]]
Отсюда проблемы.

P1, P2 - процессы, выполняются параллельно. Каждому выделяется квант. 

|P1|P2|
|--|--|
|S = S + D1| S = S + D2|

Разделяется на mov, add и mov обратно в S.

Процесс P2 потерял квант при отправке S. Он успел сложить S' = S + D2. Его получил P1. Тогда S'' = S' + D1. Квант обратно передаётся P2 и он пушит значение S'' в S.

|P1|P2|
|--|--|
|mov eax, myvar|mov eax, myvar|
|inc eax|inc eax|
|mov myvar, eax|mov myvar, eax|

Оба ядра имеют eax, оба работают с myvar.

|P1 на проц. 1|eax|myvar|eax|P2 на проц. 2|
|-------------|---|-----|---|-------------|
|mov eax, myvar|0|   0  |   |             |
|             |0  | 0   | 0 |mov eax, myvar|
|             |   |     | 1 |inc eax       |
|             |   |  1  | 1 |mov myvar, eax|
|inc eax      | 1 |  1  | 1 ||
|mov myvar, eax| 1 | 1  | 1 ||
|             |1||||

|P1|eax|myvar|eax|p2|
|--|---|-----|---|--|
|||0|||
|||квант получает p1|||
|mov eax, myvar|0|0||
|||квант получает p2|||
|||0|0|mov eax, myvar|
|сохранён аппаратный контекст|0|0|0|inc eax|
|||1|1|mov myvar, eax|
|||квант получает p1|||
|восстанавливается аппаратный контекст|0|1|1|сохранён аппаратный контекст|
|inc eax|1|1|||
|mov myvar, eax|1|1|||
Мы потеряли единицу. Опять.
Т.е. проблемы одни и те же.

Поэтому и говорят **параллельное** выполнение. Не одновременное, а параллельное. 

## Race condition. Гонки.
Переменная S и myvar называются разделяемые.

Переменные, к которым получают доступ процессы при параллельном выполнении называются критическими. Участки *кода* - критическими. К разделяемым ресурсам должен обеспечиваться монопольный доступ. Т.е. если один процесс обратился к переменной - никакой другой не может обратиться к ней. 

Монопольный доступ обеспечивается средствами взаимоисключения. Ин инглиш mutual exlusion. [[Мьютекс]]ы.

Существуют несколько методов обеспечивания взаимоисключений.
# Программный
Взаимоисключение обеспечивается в ходе программ. Пример: флаги. 
   ```c
   fp1, fp2.logical
   p1: while(1);
	   while(fp2);
		   fp1 = 1;
		   cr1;
		   fp1 = 0;
		   pk1;
	end p1
	```
   ```c
   fp1, fp2.logical
   p2: while(1);
	   while(fp1);
		   fp2 = 1;
		   cr2;
		   fp2 = 0;
		   pk2;
	end p2

	begin
		fp1 = 0; fp2 = 0;
		pasbegin
			p1; p2;
		pasend;
	end.
	```
Флаг не спасает, т.к. в p2 флаг fp1 проверяется до его изменения в p1.

```c
   fp1, fp2.logical
   p1: while(1);
	   fp1 = 1  // !!!
	   while(fp2);
		   cr1;
		   fp1 = 0;
		   pk1;
	end p1;
   
   fp1, fp2.logical
   p2: while(1);
		fp2 = 1; // !!!
		while(fp1);
		   cr2;
		   fp2 = 0;
		   pk2;
	end p2;

	begin
		fp1 = 0; fp2 = 0;
		pasbegin
			p1; p2;
		pasend;
	end.
	```
Ни один из процессов не может продолжить своё выполнение, т.к. возникает зацикливание. Это deadlock.

Активное ожидание на процессоре.

Надёжное решение было предложено математиком Деккером. Но только для двух параллельных процессов. Для корректного решения он ввёл дополнительную переменную *чья_очередь*.  

```c
    fp1, fp2.logical
	   que : int;
    p1: while(1);
	    fp1 = 1;
		while(fp2)
			if(que == 2) then 
			{
				fp1 = 0;
				while(que == 2);
				fp1 = 1;
			}
		cr1;
		fp1 = 0;
		que = 2;
		pr1;
	end p1;

	p1: while(1);
	    fp2 = 1;
		while(fp1)
			if(que == 1) then 
			{
				fp2 = 0;
				while(que == 1);
				fp2 = 1;
			}
		cr2;
		fp2 = 0;
		que = 1;
		pr2;
	endp2;

	begin
		fp1 = 0; fp2 = 0;
		que = 1;
		pas begin
			p1; p2;
		pas end;
	end
```

Лампорт: алгоритм булочная. Очередь.
Lamport's bakery algorithm.

Выдавать бумажку с номером каждому посетителю. Но в дверь могут входить двое.

Алгоритм решает проблему критической секции для N процессов. Основная идея заимствована из работы булочной. Под обслуживанием процессов понимается вход в критическую секцию. В соответствии с ранее полученным номером.

```java
1. var choosing : shared arrar [0...N-1] of boolean;
2. number : shared array[0...N-1] of integer;
3. repeat
4.     choosing[i] = true;
5.     number[i] = max(number[0], number[1], ..., number[N-1]) + 1;
6.     choosing = false;
7.     for j != 0 to n - 1 do begin
8.         while choosing[j] do (*nothing*);
9.         while number[j] <> 0 and
10.                   (number[j], j) < number[i], i) do // лексикографическое отношение
11.        (*nothing*)
12.        end;
13.        (*critical section*)
14.             number[i] = 0
15.        (*remainder section*)
16.        until false;    
```

4-6. Процесс получает следующий по порядку номер. 
7-12. Выбор, какой процесс войдёт следующим.

3. Аппаратный
4. С помощью семафоров
5. С помощью мониторов

### Zero-links
[[00 ОС]]
### Links
[[методы обеспечивания взаимоисключений]], [[взаимоисключения]]