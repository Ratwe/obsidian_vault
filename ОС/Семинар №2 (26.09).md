Разработчики UNIX создали для себя язык Си. Силуэты кода UNIX'а стали читаемыми. Именно они ввели структуры. Структуры определили всё (в т.ч. в коде ядра).

Всё ядро UNIX это структуры и функции. Причём функции тесно связаны со структурами. Т.е. код UNIX не только структурирован по модулям, крупным частям, решающим отдельные задачи.

ОС файл не анализирует. Для неё это последовательность байтов. 

Linux -- UNIX подобная ОС. Она строится на всех парадигмах UNIX:
- открытый код
- процесс - программа в стадии выполнения (владельцем ресурсов является процесс)

Но UNIX'оиды определяют:
процесс часть времени выполняется в режима пользователя, и тогда он выполняет собственный код. Часть времени в режиме ядре и выполняет реентерабельный *код*.

Система переходит в режим ядра в результате:
1. системного вызова
2. исключения
3. аппаратного прерывания

Запросив ввод/вывод, процесс будет заблокирован, пока не будут получены данные. Возврат блокировки выполняется ядром в результате обработки прерывания от внешнего устройства и ... обработчика прерываний от ...

[[Обработчики прерываний]] являются драйверами внешнего устройства. Передача запрошенных данных процессу выполняется через обработчики. Для этого процесс блокируется, переходит в режим ядра. Получив данные, перейдёт в режим задачи. Также процесс перейдёт в режим ядра при исключении. Если возникнет ошибка в коде -- процесс будет завершён. В результате аппаратных прерываний и прерываний от других устройств процесс не переходит в режим ядра. Даже наоборот, возвращается в режим задачи из состояния блокировки.

Прерывание от системного таймера выполняется в контексте процесса.

В UNIX любой процесс создаётся системным вызовом fork. Выполняется программа, ей требуется создать параллельно выполняющий процесс, в коде приложения вызывается fork. В результате этого процесс перейдёт в режим ядра. Есть разница между системными вызовами и функциями ядра. **Это разные вызовы и разные функции.**

*Говорит о том, что надо записывать дословно и буквально. Нам же лучше будет.*

В результате системного вызова [[fork]] создаётся **новый** (смотри диаграмму состояния процесса) процесс-потомок, который является копией (не говорить точная копия) приёмка в том смысле, что потомок наследует код предка, сигнальную маску, маску режимов создания файлов, дескрипторы открытых файлов. Для процесса-потомка создаётся собственное адресное пространство (виртуальная и защищённая). Виртуальное адресное пространство процесса в системе создаётся соответствующими таблицами страниц (в старом UNIX -- карты трансляции адресов). В UNIX в адресное пространство потомка копировался код предка. В результате могло существовать несколько копий одной и той же программы, что неэффективно. 

UNIX BSD
UNIX system 5
В этих системах системный вызов fork был оптимизирован, но по разному.

# Оптимизация fork
В UNIX System 5 для потомка создаётся собственная таблица страницы. Но дескрипторы страниц адресного пространства потомка ссылаются на страницы адресного пространства предка. 

Можно сказать, что потомок наследует дескрипторы страниц адресного пространства предка. В результате получается, что два или более процесса одновременно обращаются к одним и тем же страницам адресного пространства предка. Это недопустимо: один хочет изменить, а другой сохранить. Поэтому для страниц адресного пространства предка права доступа с read-wrtie меняются на readonly. И устанавливается флаг copy-on-wrtie.

В рез-те возникнет исключение по правам доступа при попытке изменить данные. В рез-те вызывается обработчик исключения, который обнаружит флаг copy-on-write. ... В рез-те создаются копии только нужных страниц. 

- сегмент кода
- сегмент данных (статические данные, объявленные в коде)
- сегмент стека

Куча - отдельный регион адресного пространства процессора. Что происходит с кучей - широко не афишируется. Но там тоже меняются указатели, а указатели статические.

В UNIX BSD эта проблема решена с помощью системного вызова vfork(), который работает по-другому. В рез-те vfork создаётся процесс потомок, но он в своё распоряжение получает таблицу страниц предка. Предок передаёт *своё адресное пространство*. Сам предок блокируется. Предок и потомок обратиться к своим страницам одновременно не могут.

Такая ситуация и с copy-on-wrtie, и с vfork() существует в системе до тех пор, пока потомок не вызовет системный вызов exit() или системный вызов exec(). Тогда в реализации system 5 флаг copy-on-write сбрасывается и процессу предку возвращаются обычные права. А в BSD предок разблокируется и получает свои страницы таблиц назад. 

- exit() - системный вызов завершения процесса.
- return - возврат управления. **Не путать.**
- exec() - системный вызов, который переводит процесс на новое адресное пространство программы, которое передаётся в exec() в качестве параметра. В рез-те начинает выполняться код другой программы. 

В UNIX процессы работают так:
1. создаётся новый процесс (fork)
2. переходит на новое адресное пространство (exec)

Любой процесс может форкнуть любое кол-во раз. Понятие форк-бомба. 

Вникнуть: терминология англоязычная. Всё, что изучаем, писали англо-саксы. И они называли всё своими именами. 

Опираемся на картинки:
![[Pasted image 20230926165156.png]]
UNIX поддерживает иерархию процессов. Поскольку есть связь потомок-предок. 

Таблица в точки зрения программиста - массив структур. Процессы создаются и завершаются динамически. Большие накладные расходы. Не может быть такой таблицы, но часто так говорят.

В UNIX все идентификаторы помещаются в integer. Предел - INT_MAX.

В системе всегда есть процесс с id 0 - это процесс, запустивший систему. И процесс с id 1 - процесс, открывший терминал. UNIX предоставляет пользователю команды shell. Мы вводим их с клавиатуры, а видим их на мониторе.

Все процессы, запущенные на терминале - потомки процесса 1.

Процессы, оставшиеся без предка - сироты. Их усыновляет процесс 1. 

При завершении **любого** процесса система проверяет, не остались ли у него незавершённые потомки. Если остались - запускается процесс усыновления. В результате потомки получаются указатель на дескриптор нового предка, а предок получит указатель на новых потомков. Это базовый принцип UNIX.

wait(&status) блокирует процесс-предок до завершения потомков. При этом предок с помощью wait() получает статус завершения своих потомков - причину завершения.

Значит, wait() блокирует процесс-предок в ожидании завершения потомка. Система не контролирует коды приложений и какой процесс вызвал wait - предок или потомок. Особо одарённые студенты вызывали wait в потомке. По идее exec() должен быть вызван в потомке, а wait() - в предке. Ну и любой потомок может стать предком, вызвав fork().

Процесс-зомби - это процесс, у которого отобраны все ресурсы *кроме последней строки в таблице процессов*: идентификатора и дескриптора. В дескрипторе написано состояние state. В результате предок сможет получить состояние потомка-зомби.

- ps выводит инфу о процессах о процессах в терминале
- ls - инфу о файлах в директории
- надо выписать из man page флаги и стэйты

```c
pid_t main() // main это предок, в нём вызываем fork()
{
	int childpid;
	if ((childpid = fork()) == -1)
	{
		perror("Can't fork");
		exit(1);
	}
	else if (childpid == 0)
	{
		// child
		printf("Child: child pid = %d, parent pid = %d", getpid(), getppid());
		exit(0);
	}
	else 
	{
		// parent
		printf("parent: child pid = %d, parent pid = %d\n", childpid, getpid());
	}
	return 0;
}

// getpid() получается собственный идентификатор
// getppid() получается идентификатор процесса предка
```

ps с помощью manual в тетрадь значения флагов и states
суперюзер - процесс, который может обращаться к структурам и функциям (коду) ядра

основная задача ОС - выполнение приложений

табличные файлы - данные, которые можно хранить длительное время

Все процессы проходят через состояния зомби, поскольку система не может дифференцировать процессы, ибо слишком много проверок. Связано это с тем, что в UNIX определена иерархия процессов. Она поддерживается всеми системами, в том числе Linux. Иерархия в отношении предок-потомок. Наличие этой иерархии делает Linux ещё более надёжной ОС. За счёт того, что процессы-предки получают код завершения своих потомков и могут его анализировать. Система не может делать какие-то проверки в больших объёмах. Если процесс создал потомка, то он будет блокирован до момента завершения потомка. Предок будет заблокирован в ожидании потомка, если wait() будет вызван после завершения потомка. Система не контролирует коды возврата. Зомби введено для того, чтобы процесс-предок не оставался в системе в блокированном состоянии.

### Zero-links
[[00 ОС]]