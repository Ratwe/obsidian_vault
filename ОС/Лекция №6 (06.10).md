...*прошло 15 минут от лекции*

Аппаратный способ взаимоисключений. В этом способе взаимоисключения реализуются с помощью test-and-set(a, b). Это машинная команда. Появилась в IBM370. Реализует проверку и установку содержимого ячейки памяти которое называется байтом блокировки. Является атомарной. Если байт блокировки 0 -- байт доступен. Если единица -- занят.  

```c
program use_ts
	flag, c1, c2 : ???;
p1: while(1)
	{
		c1 = 1;
		while(c1 == 1)
			test_and_set(c1, flag);
		CR1;
		flag = 0;
		PR1;
	}
p2: while(1)
	{
		c2 = 1;
		while(c2 == 1)
			test_and_set(c2, flag);
		CR2;
		flag = 0;
		PR2;
	}
main()
{
	flag = 0;
	posbegin 
		P1; P2;
	posend;
}
```

...Поскольку p2 находится в своём критическом участке, то flag истина. Команда test_and_set() обнаруживает этот флаг и устанавливает в c1 единицу. Таким образом p1 находится в своём цикле активного ожидания до тех пор пока p2 не выйдет из своего критического участка. Вероятность бесконечного откладывания крайне мала. 

Использование test_and_set() *в цикле проверки переменной называется циклической блокировкой* или spin lock. Иногда -- simple lock.

test_and_*lock()* чаще всего возвращает предыдущее значение переменной.

```c
void spin_lock(spin_lock_t *c)
{
	while(test_and_set(*c) != 0)
		/* ресурс занят */
}

void spin_unlock(spin_lock_t *c)
	*c = 0;

void spin_lock(spin_lock_t *c)
{
	while(test_and_set(*c) != 0)
		while(*c != 0)
}
```

# [[Взаимоисключения с помощью семафоров]]
Рассказ о классических семафорах Дейкстры. А на семинарах будем рассматривать семафоры Unix.

Смысл исследований Дейкстры: необходимо уйти от активного ожидания и он предложил механизмы семафоры. 

Бинарный семафор - значение, принимающее или 0, или 1. 

На семафоре он определил значения P и V - первые буквы датских слов. *Спич про нации, что они всегда будут, что у каждого есть родина.*
P - пропустить.
V - освободить.

P(S) - захватить. Декремент: если S > 0, то  S = S - 1.
V(S) - освободить и дать возможность другому процессу захватить семафор. Инкремент: если S == 0, то S = S + 1. 

..процесс блокируется в ожидании освобождения семафора до момента, пока другой процесс не освободит семафор.

Заблокировать и разблокировать процесс может только ОС. Поэтому P(S) и V(S) -- системные вызовы. 

Семафоры - основной *процесс* взаимоисключения. 

Операции P(S) и V(S) неделимые.

Если процесс не может сразу захватить семафор, блокируется, то он теряет квант и переходит в состояние ожидания *переключения* семафора.

## **Производство потребления.** 
Задача: имеется два типа процессов и буфер. Процессы-производители могут только производить единицу (чего хотите) данных и помещать их в буфер. Другие процессы-потребители могут только выбирать данные из буфера. 

producer -> \[  |  |  |  |  |  |  ] -> consumer

se -- количество пустых ячеек буфера
sf -- количество заполненных ячеек буфера
это два **считающих** семафора.
sb -- бинарный семафор

```c
se, sf, sb, semaphore
producer, while(1)
		  {
			  P(se);
			  P(sb); // захват критической секции
			  N = N + 1, один добавлен в буфер
			  V(sb); // освобождение критической секции
			  V(sf);			 
		  }

consumer, while(1)
		  {
			  P(sf);
			  P(sb);
			  N = N + 1, один взял
			  V(sb);
			  V(se);
		  }
		// нач. знач.
		se = N; sf = 0; sb = 1;

pos begin
	producer; consumer;
pos end
```

Производитель будет блокирован, если нет пустых ячеек, а потребитель -- если нет заполненных. Это вполне возможно, т.к. *процессы выполняются* **асинхронно** - каждый со своей скоростью. Один будет ждать другого. 
**Это наиважнейшее рассуждение.**

**В современных системах реализованы наборы семафоры, которые семантически представлены массивами считающих семафоров.** Связано это с тем, у семафоров есть одна особенность: 

## [[Семафоры против мьютексов]]
mutex - mutual exclusion. 

У семафора нет хозяина. Это значит, что семафор может освободить любой процесс. Если семафор был захвачен один процессом, то освободить семафор может любой другой процесс, не заблокированный на семафоре. В отличие от мьютекса и другого средства lock и unlock, у которого хозяин есть - там освободить может лишь тот процесс, который захватил.

```c
p1: ...
	P(S);
	...
	
p2: ...
	V(S);
	...
```

В семафоре может возникнуть тупик: первый процесс захватывает S1, второй -- S2. Потом первый хочет захватить S2, а второй процесс -- S1. В итоге тупик -- оба процесса заблокированы. Поэтому в современных ОС определены наборы семафоры.

## Свойство наборов семафоров
Одной неделимой операцией можно изменить все или часть семафоров набора.

Задача "Обедающие философы". Классическая модель захвата и распределения ресурсов решается с помощью набора семафоров:

За круглым столом сидят пять философов. Перед каждым стоит тарелка. Если это китайцы, то каждому нужно две палочки. А если итальянцы -- две вилки. И имеется три способа действия философов:

### Zero-links
[[00 ОС]]

### Links
[[взаимоисключения]]