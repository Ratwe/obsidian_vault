Пакет - объект с адресом, куда доставить.

send, recieve, reply - системные вызовы.

Есть два процесса: p1, p2.

В какой-то момент процесс p1 посылает процессу p2 сообщение. Для этого вызывается системный вызов send(). Процесс p2 может находиться в любой точке выполнения, процессы асинхронны.

Получив сообщение, p2 его обрабатывает, формирует ответ (если p1 нуждается в ответе), и вызывает reply().

Получив ответ, p1 может продолжить выполнение.

Диаграмма - три состояния блокировки процесса при передаче сообщений.

![[20231027_160206.jpg]]

p1 посылает сообщение и блокируется (блокировка в ожидании ответа)
Процесс p2 получает сообщение и отправляет ответ процессу p1.
Процесс p1 получает ответ и блокируется при приёме.

# [[Алгоритмы взаимодействия процессов в распределённых системах]]
## Централизованный алгоритм
Централизованный алгоритм - в этом алгоритме взаимодействие процессов построено в соответствии с взаимодействием процессов в отдельно стоящем процессоре. 

Есть процесс-координатор. Когда какой-то процесс хочет войти в свой критический участок - посылает координатору запрос, в какую критическую секцию он хочет войти. Координатор проверяет, нет ли какого другого процесса в этой критической секции, и не запросил ли другой процесс вход в эту секцию. 
Если процесс там уже есть - координатор ставит запрос в очередь. Если два процесса запросили вход в один и тот же критических участок - проверяет, когда у процесса возник такой запрос. Если один запрос раньше другого - координатор разрешает ему войти. Другой ставит в очередь. 

Этот алгоритм часто называется алгоритм-забияка. Потому что работоспособность зависит от наличия процесса-координатора. Если он завершился аварийно, то система становится неработоспособной.

Когда какой-то процесс обнаруживает отсутствие процесса-координатора запускается процесс выбора нового координатора. Когда это происходит? - когда истекает timeout(), а сообщение приёма не приходит. В таком случае процесс начинает выборы нового координатора. Для этого процесс посылает спец. сообщение, которое обозначим как **ВЫБОРЫ**, в котором указывает свой номер, идентификатор. Процесс, получивший это сообщение, сравнивает свой номер с тем, что в сообщении. Если его номер больше - он сам рассылается сообщение о **ВЫБОРАХ** со своим номером.

В результате этих **ВЫБОРОВ**, будет выбран процесс с наибольшим (сетевым) номером. Он становится новым координатором.

Если процесс не получил ни одного ответа - он и становится этим процессом координатором. 

Очевидные проблемы:
- все взаимодействующие процессы должны быть готовы стать координаторами. Для этого должно быть установлено ПО координатора и ПО *процесса*.

## Распределённый алгоритм
Опять же есть n взаимодействующих процессов. Соответственно, они могут обращаться к одним и тем же разделяемым ресурсам. Работа с этими ресурсами должна выполняться в режиме взаимоисключения. Семафоры использовать не можем.

Когда любый из процессов желает войти в критическую секцию по какому-либо ресурсу, он посылает n-1 сообщение с указанием критической секцией и времени отправки этого сообщения всем взаимодействующим процессам. При получении такого сообщения у другого процесса возможны 3 ситуации:
1. Если процесс-получатель не собирается входить в данную CR, то он посылает процессу, запросившему вход, сообщение разрешения.
2. Процесс-получатель сам находится в данной критической секции. В этом случае он ставит запрос в очередь. Ответ не посылает.
3. Процесс получатель сам захочет туда зайти, но ещё не успел это сделать. Тогда он сравнивает время пришедшего в сообщении запросе и время своего запроса. Если его время позднее - посылает сообщение разрешения. Иначе - ставит запрос в очередь.

Таким образом, чтобы войти в критическую секцию, процесс должен получить n-1 сообщение о разрешении. 

## Token ring
Процессы образуют логическое кольцо.

Каждый процесс знает, кому должен отправлять сообщение.

По этому кольцу движется так называемый ***токен*** - специально сообщение, в котором указана критическая секция. Таких токенов будет столько, сколько критических секций. 

Если процесс находится в критической секции токена - он его удерживает. Когда выходит - отдаёт токен дальше. Если процесс не заинтересован в критической секции - отправляет токен сразу.

## Что надёжнее?
Распределённый алгоритм ненадёжен, поскольку любой из взаимодействующих процессов может завершиться и процесс никогда не получит n-1 разрешений.

Аналогично с кольцом - любой завершающий процесс разрывает кольцо.

Наиболее надёжный способ - централизированный алгоритм.

## [[Транзакции]] (неделимые)
По определению любая транзакция должна быть неделимой. Иначе это не транзакция. Её прервать нельзя.

Модель неделимой транзакции пришла из бизнеса. Представим процесс переговоров двух фирм о купле-продаже чего-то...

Один процесс объявляет о желании начать транзакцию. Процессы могут некоторое время создавать и уничтожать некоторые объекты. Затем процесс объявляет о том, что хочет завершить транзакцию. Если все согласны с завершением - результат транзакции фиксируется. Его изменить невозможно. Если один из процессов не готов завершить транзакцию, то транзакция не фиксируется. Т.е. транзакция имеет свойство "**всё или ничего"**.

Транзакцией называется последовательность операций надо одним или несколькими объектами (например объекты БД, файлы, записи и т.п.), который переводят систему из одного целостного состояния в другое целостное состояние.

Очевидно, что транзакции должны поддерживаться системой. нужны примитивы begin_transaction(), end_transaction(), abort_transaction(), read-write.

### [[Свойства транзакций]]
ACID:
1. Атомарность (Atomic). 
   Всё выполнилось - фиксируем результат commit. 
   Если хоть одна ошибка - откат rollback.
2. Согласованность, упорядоченность (Consistent). 
   Пример: если товар куплен, то это должно быть зафиксировано в системе товарного учёта и числиться как проданное.
3. Изолированность (Isolated).
   Транзакция изолирована от других транзакций и процессов, т.е. информация из них ей недоступна.
4. Устойчивость (Durable).
   При завершении транзакции все *результаты* зафиксированы и никакой сбой к *потере данных привести не может.*

... второй подход - список намерений. Модифицируются сами исходные объекты - файлы, записи, а не копии. Но перед изменением производится запись в журнал регистрации исходного и изменённого значения объекта. ...

![[20231027_171620.jpg]]

... именно транзакции должны избегать тупиков.

### Zero-links
[[00 ОС]]