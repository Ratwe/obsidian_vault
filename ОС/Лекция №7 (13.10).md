Задача "Обедающие философы". Классическая модель захвата и распределения ресурсов решается с помощью набора семафоров:

За круглым столом сидят пять философов. Перед каждым стоит тарелка. Если это китайцы, то каждому нужно две палочки. А если итальянцы -- две вилки. И имеется три способа действия философов:

Задача о пяти философах:
1. Каждый пытается взять сразу два прибора -- левый и правый. Если ему удаётся, он начинает есть. Поев, возвращает оба прибора.
2. Каждый берёт правый прибор, пытается взять левый, удерживая правый.
3. Каждый берёт правый, если не может взять левый -- возвращает правый.

Результаты:
1. Приводит к **бесконечному откладыванию**. От голода умрёт один философ, потому что будет постоянно ждать.
2. Классический **тупик** - deadlock. Смертельный захват.
3. Все взяли правый прибор, не могут взять левый. Возвращают правый. Пытаются взять правый - возвращают левый. **Захват и освобождение одних и тех же ресурсов**. 
Полезная работа при этом не выполняется.

```c
var forks, array[1...5] of semaphore;
	i : integer;
begin
	repeat
		forks[i] := 1;
			i = i + 1;
	while i = 0;
posbegin
	1: begin // первый философ 
		left := 1; right := 2;  // берёт первый и второ прибор
		...
		end
	5: begin
		left = 5;
		right = 1;
		repeat
		// размышляет
		P(forks[left], forks[right]);
		// ест
		V(forks[left], forks[right]);
	forever
	end; //5/
posend;
```

# [[Мониторы]]
"Проблема, связанная с семафорами и аналогичными средствами, обеспечиваемыми ОС, состоит в том, что они не структурны." 

**Основная особенность семафора - у него нет хозяина. Т.е. освободить семафор может любой процесс**, в отличие от других блокирующих примитивов, которые освободить может только тот процесс, который захватил примитив.

Для семафоров очень важно помнить, что **его может освободить любой процесс.** 

...только система может заблокировать и разблокировать процесс.

lock - wait(c) - wait(c)
unlock - post(c) - signal(c)

# Монитор
Монитор является средством структурирования средств ожидания и оповещения. Исторически сначала появились мониторы, потом классы.

**Монитор - структура, содержащая данные, и функции, позволяющие изменять эти данные.**

Монитор м.б. реализован в ОС в языке программирования.

Классическая реализация монитора предполагает две функции:

## Простой монитор

Начнём с простого монитора, поскольку он обеспечивает выделение ресурса произвольному кол-ву процессов.
```c
monitor:resourse
var 
	busy:logical;
	x:counditional;
procedure acquire;
	if busy then wait(x);
	busy := true;
end
procedure release;
	begin
		buse := false;
		signal(x);
	end;
	begin
		busy := false;
	end.
```

Когда процесс освобождает ресурс - вызывает release, даёт сигнал, сбрасывает логическую переменную. ...

Все суждения очень похожи на те, которые проводились для семафора. Других быть не может. Это всегда делает ядро: блокирует и разблокирует. Но тут к переменным монитора можно обратиться только через функции монитора.

## Монитор кольцевой-буфер
Существует два типа процесса: которые могут только производить и класть в буфер, и те, которые могут только выбирать из буфера.

### Решение Дейкстры
```c
monitor:resourse
var
	bsignal:array[0...n-1] of type;
		pos:0...n; // текущая позиция
		j:0...n-1; // заполняемая позиция
		k:0...n-1; // освобождающаяся позиция
	buffer.full, buffer.empty:conditional;
	procedure producer (data, type);
```

## Монитор читатели-писатели
Процессы-читатели могут только читать данные.
Процессы-писатели могут только изменять данные.

Мониторы Н.Ю. читает нам по книге Дейтела - ОС.

В мониторе четыре функции:
- start read
- stop read
- start write
- stop write

```c
monitor:resourse;
var
	nr:integer; // кол-во читателей
	wrt:lofical; // активный писатель
	c_read; c_write:conditional;
procedure stastread;
	begin
		if wrt or turn(c_write)
			then wait(c_read);
		nr := nr + 1;
		signal(c_turn);
	end;
```

Пример - системы массовой продажи билетов. Читатели читают параллельно. Писатели могут работать только в режиме монопольного доступа.

```c
procedure stopwrite;
	begin
		wrt := false;
		if turn(c_read) then signal(c_read)
			else signal(c_write);
		end;
	begin
		nr := 0;
		wrt := false;
	end
```

Особенность данной реализации монитора - цепная реакция по активизации читателей. Невозможно бесконечное откладывание читателей и писателей из-за соответствующей проверки. 

Например, писатель может писать, если нет активных читателей. Читатель также проверяет, есть ли ждущие писатели. Если есть - читатель не сможет начать читать.

### Zero-links
[[00 ОС]]