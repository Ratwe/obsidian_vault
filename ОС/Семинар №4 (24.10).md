# [[Сигналы]]
Сигналы UNIX являются средством информирования процессов о событиях, которые происходят как в самом процессе, так и вне процесса.

В windows есть ивенты.

Если события происходят в самом процессе, то это - синхронное событие для процесса. Если вне процесса - асинхронное. Где мы уже проходили синхронность и  асинхронность? - в прерываниях. *Системные прерывания синхронны*. Аппаратные прерывания - абсолютно асинхронны. 

События, происходящие в системе асинхронны - их скорость выполнения не зависит от других процессов.

*- ...понятно, что я говорю? Мне кажется, вам вообще не понятно, что я говорю. Настолько вы далеки от техники.*

Как правило, важнейшее событие в системе - завершение процесса. 

Сам процесс может определить собственную реакцию на сигнал:
1. Сигнал может быть проигнорировал процессом
2. Процесс может отреагировать на сигнал по умолчанию - способом, определённым в системе.
3. Определить собственную реакцию на сигнал.

В классическом UNIX сигналов не могло быть больше 20.

В системе имеются обработчики всех сигналов. Например, в WinXP мы видели обработчик 8го прерывания. У каждого сигнала есть свой обработчик без исключений.

Сигналы имеют два способа их идентификации:
- NSIG 20
- SIGHUP 1
* SIGINT 2  // остановка процесса пользователем с терминала ctrl + c
* SIGQUIT 3 // ctrl + /
* SIGKILL 9 // со значением 9 возникает, когда в коде вызывается сис. вызов kill()
* SIGSEGV 11 // ошибка сегментации
* SIGSYS 12
* SIGALARM 14
* SIGTERM 15
* SIGVSR1 16
* SIGVSR2 17
* ...

Соглашение ЮНИКС: то, что определено в ядре - большими буквами.
SIGHUP - *сигнал* разрыва связи с терминалом.

-*Я хочу, чтобы вы с своей голове устанавливали логическую связь между информацией, которую вы получаете... Иначе никакого толку не будет. И самое страшное - в вашей работе.*

Демон не должен иметь управляющий терминал. Сигнал SIGHUP в коде демона игнорируется. 
-*Просто сама провожу эту связь между информацией, которую сама же и говорю. Пожалуйста, обращайте на это внимание.*

Совершенно по-разному система завершает процессы. *Спич про ctrl+c*. 

## [[Системный вызов kill]]
```c
int kill(imt pid, int sig);
```

Процессы одной группы могут получать одни и те же сигналы.

Важнейшая группа - терминальная. Процесс, вызвавший fork(), создаёт свою группу, является её лидером. 

если pid <= 1 ...
если pid = 0
сигнал будет послан всем процессам с идентификаторами группы, совпадающими с идентификатором группы процесса, который вызвал kill, кроме процессов с идентификаторами 0 и 1.

```c
kill(getpid(), SIGALARM);
```
сигнал SIGALARM будет послан процессу, который вызвал kill
## POSIX
POSIX 1 FIPS
Portable Operating System Interface based on UNIX.
Federal Information Processing Standart

В последней версии POSIX в 1988г. включал в себя 1000 вызовов.

Операционные системы предоставляют нам системные вызовы. Этот стандарт их и перечисляет.

POSIX 2 - расширение POSIX 1.

## X/Open Portability Guide
XPG4, XPG4 (1994г)

## [[Системный вызов SIGNAL]]
```c
void (*signal(int sig, void(*handler)(int)))(int);
```
Реакция процесса, вызвавшего этот системный вызов, будет вызов обработчика handler. Системны вызов SIGNAL позволяет обработчики устанавливать собственный сигнал sig. При этом сис. вызов SIGNAL возвращает указатель на старый обработчик сигнала.

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <iostream.h>
void sig_handler(int sig_num)
{
	signal(sig_num, sig_handler);
	cout << "catch sig" << sig_num << endl;
	printf("sig catch %d", sig_num);
}

int main()
{
	printf("This is the test\n");
	signal(SIGTERM, sig_handler);
	signal(SIGINT, SIG_IGN);
	singal(SIGSEGV, SIG_DFL);
	pause();
	return 0;
}
```

в 5й программе, используя вызов signal 
на любой вариант сигнала. Удобнее всего SIGINT. Вешаем свой обработчик сигнала. При этом сигнал позволяет менять нам ход выполнения процесса. Для этого достаточно объявить переменную flag и в обработчике сигнала эту переменную уст. И соответственно ветвиться по этой переменной. Возьмём простейший вариант - прогу с пайпом. В ней по сигналу чайлды записывают свои сообщения в пайп. Если сообщения записаны, то парент может их получить. Если сигнал не поступает - чайлды в пайп ничего не пишут и парент прочитать ничего оттуда не может. Парент не читает по флагу. По флагу чайлды пишут в пайп. Если есть процесс пишущий в трубу, то читающий процесс сможет прочитать. Главное - правильно понять действия системы, как написан код системы. 

При этом, в этой программе в main не объявлять массив строк. Строки задаём в адресном пространстве чайлда. В нашем форе легко это сделать путём ветвления по i. И буфер никакой для чтения не использовать. Из трубы читать посимвольно и каждый символ выводить на экран. Исключает все буфера кроме одного - пайп - буфера типа фифо в адресном пространстве ядра. 

Главное - правильное понимание работы системы. Чайлды пишут в буфер ядра. Нет другого буфера в программе. Массив строк, с точки зрения программирования - буфер *режима* пользователя. Но можно не объявлять никакого буфера. До бешенства выводит слово **литерал**. Если в printf строка - литерал. А если char* msg = "....", у него есть идентификатор msg, это не литерал.

Процесс, посылая сигнал, может повлиять на выполнение другого процесса.

```c
#include <signal.h>
int main()
{
	void(*old_handler)(int) = signal(SIGINT, SIG_IGN);
	...
	singal(SIGINT, old_handler);
	...
}

int sigaction(int sig, struct sigaction *action, struct sigaction, *old_action);
sigset();
sigjump();
```

Читателей-писателей пишем в двух. В виндах делаем на ивентах. И за уши притягиваем один мьютикс просто для знакомства.

Сигнал устанавливает для конкретного процесса, а не для всей системы.

### Zero-links
[[00 ОС]]
