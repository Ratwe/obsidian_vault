# Требования Рязановой Н.Ю.
Какой процесс (id) какую букву написал, кто какую взял.
Массив не объявлять, все действия выполнять через указатели.
Не меньше трёх производителей и трёх потребителей. 
Создаём форком.
Это - асинхронные процессы, выполняющиеся с разной скоростью.
Необходимо использовать абсолютно случайные задержки с изменением начальной установки задержки.
В буфер процессы пишут буквы латинского алфавита. 
Размер буфера ставят 1024.
Если объект взят из буфера - ячейка перестаёт существовать.

Соответственно, в буфере, начиная с начального адреса, положить текущий адрес производителя. Затем текущий адрес потребителя. Затем - текущую букву. Следующий производитель не знает, какая буква положена. Он же её не читает. Поэтому надо сохранять. 

Начальное значение: "а".
Выход по сигналу SIGINT. 
Потомки наследуют обработчики сигналов.
В struct_task_struct есть signal handler \*signal.
Потомки наследуют обработчики сигналов.

Вопросы и ответы:
охарактеризовать задачу производства-потребления
в чём её особенность

8 рабочих 1 управляющий процесс
сущ два типа процессов - производители и потребители
читают/записывают в сегмент разделяемой памяти

задача, в которой существует два типа процессов:
продюсеры производят единицу данных и могут только помещать данные в буфер
а консьюмеры могут только брать данные из буфера

consumer блокируется на семафоре буфер полон, когда нет заполненных ячеек и на бинарном семафоре 

Бинарный семафор обеспечивает монопольный доступ к конкретной ячейке памяти (критической секции)

почему четыре раза выполняются операции над семафором:
по алгоритму Дейкстры каждый раз неделимая операция выполняется над двумя семафорами наборов(?)
поэтому для выполнения этих действий (каждый раз два действия)

почему четыре массива структур?
каждая операция должна быть атомарной, соответственно каждый семафор отвечает за свою операцию.

Что потомки наследуют? Перечислить.
## Сдача лабы

![[Recording 20231121160154.webm]]

![[Recording 20231121163110.webm]]

![[Recording 20231121165406.webm]]

![[Recording 20231121170254.webm]]

-----
Вторая программа - читатели-писатели.
Если посмотреть запись монитора, то там исп. функция тёрн() - очередь ждущих писателей и читателей. Заменяем счётчиком ждущих писателей, активных читателей, ждущих читателей. Три считающихся семафоров и один бинарный семафор активного писателя, который реализует работу активного писателя. Т.е. с помощью бинарного семафора реализуется взаимоисключение писателей. Но в то же время, если есть активный писатель - ни читать, ни писать нельзя.

start_write, stop_wrtie, start_read, stop_read.

Читатель может начать читать в start_read, если нет активного писателя и ждущих писателей. У некоторых не получается. Решение:
создать теневой семафор, тогда пять (????????????). 

Читатели-писатели переменные типа integer. Писатели только инкрементируют значение переменной, читатели - декрементируют.

Кто (id) значение взял, кто отдал.
Начальное значение: 0.

## Сдача лабы

![[Recording 20231128145150.webm]]
Есть два типа процессоров: писатели могут только изменять данные в переменной в режиме монопольного доступа. Могут читать параллельно из разделяемой переменной. Писатели могут только изменять разделяемую переменную в режиме монопольного доступа.

Каким образом к разделяемой переменной реализуется монопольный доступ - при помощи бинарного семафора bin_sem.

Когда читатель сможет читать? 

Как могут работать читатели/писатели? Параллельно/в режиме монопольного доступа.

Использует для захвата критической секции. Т.е. для обеспечения монопольного доступа.

А зачем ещё дополнительный семафор ACTIVE_WRITER?
![[Recording 20231128162236.webm]]

Имеет ли место такая реализация, где мы 
![[Recording 20231128164630.webm]]

---
## Readers-writers на Windows
```c
HANDLE readers_threads[READERS_NUM];
HANDLE writers_threads[WRITERS_NUM];
```
Зачем здесь [[HANDLE]].

```c
if ((mutex = CreateMutex(NULL, FALSE, NULL)) == NULL)
{
    perror("Failed to CreateMutex");
    return -1;
}
```
Про [[CreateMutex]].

```c
if ((can_read = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
{
    perror("Failder to CreateEVent can_read");
    return -1;
}
if ((can_write = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
{
    perror("Failder to CreateEVent can_write");
    return -1;
}
```
Про [[CreateEvent]].

```c
DWORD thread_id[WRITERS_COUNT + READERS_COUNT];
```
Про [[DWORD]].

```c
for (int i = 0; i < WRITERS_COUNT; ++i)
{
	process_nums[i] = i + 1;
	thread_handler[i] = CreateThread(NULL, 0, writer, &process_nums[i], 0, &thread_id[i]);
	if (thread_handler[i] == NULL)
	{
		perror("Can't create writer thread");
		exit(EXIT_FAILURE);
	}
}
```
Про [[CreateThread]].

- В дополнение после сдачи лабы по читателям-писателям под винду:  
 1) Есть условный кусок кода с мьютексом:  
```c
WaitForSingleObject(mutex, INFINITE); 
InterlockedIncrement(&active_readers); 
InterlockedDecrement(&waiting_readers);  
SetEvent(can_read);  
ReleaseMutex(mutex);  
```
Что здесь делает мьютекс?  
Ответ: делает операции неделимыми  

2) (К предыдущему ответу) Что значит неделимыми? [[Транзакции]].
Ответ (примерный): ни один процесс не может прервать последовательность выполнения этих операций (точную формулировку я забыл, так что чекните в лекциях, она говорила)

Далее ответы примерные, формулировки не гарантирую. По большей части нужно в коде это показать  
3) Почему читатели читают подряд?  
Ответ: потому что событие can_write наступает, когда нет активных писателей (пока есть читатели, писатели не могут начать писать).
4) Почему не происходит бесконечного откладывания читателей?  
Ответ: в stop_write покажите на проверку и поясните ее  
```c
ResetEvent(can_write); 
InterlockedExchange(&active_writer, false);  
if (waiting_readers > 0)  
{
SetEvent(can_read);  
}
```

Тот же вопрос про писателей: в start_write проверяем очередь ждущих писателей  
  
Если что: событие can_write с ручным сбросом, событие can_read с автосбросом (В Стивенсе перевод кривой)  

У ребят в лабе по линукс было ещё что-то про "Почему читатели/писатели дочитывают/дописывают после получения сигнала?". Тут про то, что читатель-писатель уже находится в теле цикла while(flag), а сигнал является внешним ассинхронным событием (ассинхронно - независимо от того, что делает процесс)

Вопрос мне:
	Особенность данной реализации монитора - цепная реакция по активизации читателей. Невозможно бесконечное откладывание читателей и писателей из-за соответствующей проверки. 

Каждый читатель инициализирует чтение следующего пока все не прочитают.
![[Recording 20231205172031.webm]]


### Links
[[Потоки]]