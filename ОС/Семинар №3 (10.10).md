# [[exec]]
По сути лаба -- продолжение базовых системных вызовов.

Linux - UNIX подобная ОС. Содержит те системные вызовы, которые мы изучаем.

Первая программа:
1. Программа с fork, при этом снова моделируем ситуацию возникновения процессов-сирот. 

Четыре программы, но не меньше двух потомков.

Исправить: проверка на минус единицу, вместо return поставить exit(1). А child'ы завершаются в exit(0). Exit() - системный вызов завершения процесса, return - возврат управления.

```c
main()
{
	pid_t childpid;
	if ((childpid = fork()) == -1)
	{
		...
		exit(1);
	}
	else if (childpid == 0)
	{
		printf("Child: pid=%d, ppid=%d, gpid=%d\n", getpid(), getppid(), getpgrp());  // выводится предок процесса
		sleep(2);
		printf("...", ...);  // выводится ppid, который принял осиротевший процесс
		exit(0)
	}
	else
	{
		...
	}

	// вот тут писать for для второго задания 
	
	return 0;
}
```
Тут один child, а у нас несколько. Стоит объявить массив идентификаторов потомков. 

Программирование это про анализ.

2. В parent вызываем waitpid(). Берём тело цикла без do while и continue.
```c
w = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);
                   if (w == -1) {
                       perror("waitpid");
                       exit(EXIT_FAILURE);
                   }

                   if (WIFEXITED(wstatus)) {
                       printf("exited, status=%d\n", WEXITSTATUS(wstatus));
                   } else if (WIFSIGNALED(wstatus)) {
                       printf("killed by signal %d\n", WTERMSIG(wstatus));
                   } else if (WIFSTOPPED(wstatus)) {
                       printf("stopped by signal %d\n", WSTOPSIG(wstatus));
                   } else if (WIFCONTINUED(wstatus)) {
                       printf("continued\n");
                   }
```
parent будет ждать каждого из потомка, но для параллельности надо писать не в for, где создали child, а в main после ветви parent'а. Main это parent. Иначе не увидим параллельность.

Child создать в for'e, после ветви parent перед return.
После else идёт for, в нём waitpid...

Здесь нет смысла писать sleep().

3. exec. В child'ах 
Системный вызов exec, *как говорят*, создаёт низкоуровневый процесс. 
Почему они так говорят - потому что процесс не создаётся. Не идентифицируется, ему не выделяется дескриптор. Но для программы, которой передаётся exec в качестве параметра, создаётся адресное пространство. Это значит, создаются таблицы страниц. Другими словами: для программы, которой передаётся exec в качестве параметра создаются таблицы страниц, которые содержат дескрипторы страниц адресного пространства этой программы.

Начинается системный вызов exec с проверок. Они указаны в *вахалии* (где 12 пунктов). Если все проверки пройдены, таблицы созданы, то инициализируется аппаратный контекст. При этом в регистры заносятся нули, а в счётчик команд или intel_ip заносится **адрес точки входа** программы (main). 

Точка входа - место, с которого начинается выполнение программы. Соответственно, в приложения точка входа это main. Но есть программы с несколькими точками входа. Например - ОС. Тут аппаратные прерывания, исключения... Драйвера тоже имеют несколько точек входа. Одна из точек входа в драйверах - обработчик прерывания, которое вызывается от аппаратного прерывания (int 8h).

В регистр CR3 нужно загрузить адрес таблицы страниц. 

В результате форка для потомка создаётся собственное адресное пространство, т.е. таблица страниц. Соответственно, адрес этих таблиц страниц загружается в регистр CR3. Для потомков создаётся дескриптор, в дескрипторе есть *поле virtual memory*. 
struct mm_struct		\*mm; в struct_task_struct.

Exec вызывается после fork, создаются таблицы страниц, в exec передаётся исполняемая программа. Вот для неё создаётся адресное пространство. В результате в дескрипторе процесса будет заменён адрес старых таблиц страниц на адрес новых таблиц страниц, и в регистр CR3 будет помещён адрес этих таблиц страниц, а в ip - адрес точки входа в программу. В дескрипторе или в поле virtual memory, или в поле mm, *загружается адрес таблицы страниц*. 

В процессорах есть пять регистров управления. CR они называются: CR0, CR1, CR2, CR3, CR4 - Control Register.
- CR0 - регистр слово-состояния процессора
- CR1 - не используется по-моему
- СR2 - регистр линейного адреса страничного прерывания
- CR3 - если 32 бит, то там находится адрес каталога таблиц страниц. В 64 бит преобразование PAE - phisycal adress extension. Адрес таблицы указателей на указатели, т.е. адрес таблиц четвёртого уровня.

Имя исполняемого файла указывать с расширением .o или .out.

Карты трансляции адресов - таблицы страниц.

Мы в своей программе создаём не меньше 2 потомков. Каждому из потомков передаём программу. Причём передаём свои программы, которые мы писали на занятиях, в которой обязательно должен быть ввод с клавиатуры: scanf(), read(). Чтобы увидеть, что программа будет блокироваться на вводе, и квант будет передаваться другой программе. Потому что мы запускаем параллельные процессы. На выводе процессы не блокируются, потому что видеобуфер проецируется...

Важно, чтобы wait() вызывался в конце main'а, а child'ы завершались exit'ом.

4. Потомки и предок обмениваются сообщениями через неименованный программный канал.
Существуют два вида программных каналов: именованные и неименованные. У именованного есть имя и дескриптор, при этом в любом случае является буфером типа FIFO. У неименованного есть *только дескриптор.*

```c 
int
main()
{
	int fd[2]; // ФД - файл дескриптор
	pid_t childpid;
	pipe(fd);
}
```
Неименованный программный канал создаётся системным вызовом pipe(). На программных каналах реализовано взаимоисключение: в канал нельзя писать, если его читают, и из канала нельзя читать, если в него пишутся. Объявляется массив файлов-дескрипторов.

Оба потомка пишут в один программный канал свои сообщения. **Запрещается передавать какие-то осмысленные сообщения**. Первый child передаёт три буквы, второй - десять. Размер сообщения определять динамически - sizeof(). Parent их читает три раза. Чтобы убедиться, что прочитанное сообщение перестаёт существовать: читает от первого, второго, читает третий раз -- труба пустая. Писать в один buf неопределённого размера.

------
Программные каналы контролируются файловой подсистемой, т.к. определены как специальные файлы. 

Программный канал буферизуется на трёх уровнях....

Системные области памяти. Если системная память переполнена, то трубы, существующие дольше остальных, переписываются на диск. Если процесс пытается записать в трубу больше, чем 4096 байт (одна страница), то труба буферизуется во времени до тех пор, пока вся информация из него не будет считана. Если процесс заполнил 4096 байт, то он будет блокирован до тех пор, пока другой процесс не освободит программный канал. Точно также, если процесс пытается читать из пустого программного канала, то он будет блокирован, пока другой процесс туда не положит информацию. Если есть пишущий процесс, но не читающего - это ошибка.

Ни один процесс не может обратиться к адресному пространству другого процессора. Процессы могут взаимодействовать только через третье адресное пространство - адресное пространство ядра системы.

### Zero-links
[[00 ОС]]

### Links
[[адресное пространство]]